# DailySolve 

### 풀이 프리뷰

dfs, bfs와 같이 방문해야할 인덱스들을 방문할 수 있는 모든 경우를 계산해서 최소값을 반환해야 예외없이 할 수 있다.   

1. 이름을 순회하며 알파벳을 만들기위해 A에서 몇번 움직였을지 계산하여 결과에 더하고 A가 아닌 알파벳이 있는 곳의 인덱스들을 따로 저장해둔다.
2. 현재 커서가 0에 있다고 가정한다.
3. 인덱스모음의 첫번째가 현재 커서에서 앞으로 얼마나 가야하는지 계산한다.
4. 인덱스모음의 첫번째를 제거한다.
5. 인덱스모음의 마지막이 현재 커서에서 뒤로 얼마나 가야하는지 계산한다.
6. 인덱스모음의 마지막을 제거한다.
7. 3,5의 인덱스 모음은 기존 인덱스 모음에서 복사하여 진행한다. 그 이유는 같은 인덱스 모음이 해당 시점에서 다른 결과를 저장한 인덱스모음으로 나뉘어야하기 때문이다.
8. 3~6의 결과를 가지고 다시한번 3~6를 진행한다.
9. 8은 인덱스모음이 빌때까지 반복한다.
10. 재귀하며 3, 5의 값을 더한 값을 결과에 더해 반환한다. 

### 피드백
예전에 풀었던 방법이 문제의 테스트케이스가 바뀌며 통과하지 못했다.   
예전 방식에서 dfs와 같은 알고리즘을 적용해서 모든 경우를 구해 풀 수 밖에 없었다.   
다른 사람의 풀이에서는 더 짧은 풀이가 있었지만 도무지 이해가 가지 않았다.   
좀 더 노력해야겠다.
